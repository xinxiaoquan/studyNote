/*javascript*/

javascript是由三部分构成
	1. 核心（ECMAScript）
	2. 文档对象模型（DOM）
		document object model
		和页面进行对话，操作页面内容
	3. 浏览器对象模型（BOM）
		browser object model
		和浏览器进行对话，操作浏览器
折行操作：
	document.write("hello \
	world!");
变量命名法：
	1. 匈牙利命名法
	2. 驼峰命名法：如果变量名由一个单词组成，就全小写。如果多个单词组合，第一个单词小写，剩下每单词首字母大写（小驼峰）
	3. 下划线命名法
console.log(a,b,c); //可以这样输出
常量声明和使用
	程序中声明好，运行不能修改的数据，称为常量
	const 常量名=值; 
	常量名称一般采用全大写的模式
进制：
	以0开头的表示8进制的
		比如：var a = 010; //表示8
	以0x开头的表示16进制（x是埃克斯）
科学计数法：
	3.14e2  表示3.14*(10^2)
数据类型：
	保存在内存中的数据类型，决定了数据在内存中占据多大空间
	分类：
		1. 基本(值)数据类型
			Number：可以表示32（4字节）位整数，也可以表示64为浮点数
			String：字符串字符串类型，表示一系列文本字符数据，由Unicode（每个字符占2字节，16位）字符、数字、标点组成
				查看字符的UNicode编码  "好".charCodeAt()
				"好".charCodeAt().toString(2) 转2进制
				16进制转字符串 console.log("\u5f20");
				转义字符：
					\n 换行
					\t 制表符
					\r 回车（接受指令）
					\' '
					\" "
					\\ \
			Boolean：布尔 true false
			undefined：不存在数据
				产生它的场合：
					1. 声明变量未赋值
					2. 访问对象属性不存在
		2. 引用类型
      Object 任意对象
      Function 一种特别的对象(可以执行)
      Arrary 一种特别的对象(数值下标,内部数据有序)
  判断数据类型：
    typeof 返回数据的数据类型字符串表达，不能判断null和数组
    instanceof a instanceof Object a是不是Object的实例，判断对象的具体类型
    === 可以判断null和undefined
  数据类型：基本类型 对象类型
  变量类型(变量内存值的类型)：基本类型 引用类型
弱类型：
	由数据决定数据类型
	typeof() 获取数据的数据类型
		typeof(a)  或  typeof a
		typeof 也是运算符
数据类型的隐式转换：
	转数字：
	0/0.0/NaN/undefinded/null/''/ -> false(其他 -> true)
	null/false -> 0
	true -> 1
	转布尔：
	内容为数字的字符串 -> 数字(其他 -> NaN)
	转字符串：
	undefined -> "undefined"
	null -> "null"
	true -> "true"
	false -> "false"
	数值型，NaN，0转成相应的字符串
什么是数据：保存在内存中特定信息
什么是内存：
算术运算符：
	加运算
		任何一种数据类型的数据，与string做加法运算，都会转成string，再连接
		数字+boolean （布尔转数字）
		数字+undefined （NaN）
		boolean+undefined （NaN）
		NaN 不是一个数（Not a Number）
		isNaN() 作用：判断是否为非数字类型，返回boolean值（会隐式转换，把字符串中的数字转成数字）
	- * / %
		如果两边的操作数不是number类型，会试图用number()转为数字，无法转就是NaN，结果则为NaN
	+,-,*,/,%,++,-- 的优先级
		先++或--，再乘除模，再加减
		提升优先级，加括号
	1. toString()
		任意数字类型转换为字符串
		如果是数字还可以指定转换的进制
		语法：数据.toString()
	2. parseInt()
		将数据转整数，number类型。
		碰到第一个非整数字符，停止转换。
		无法转换时，转为NaN
		第二个参数指定转换的进制
	3. parseFloat()
		将数据转浮点数，number类型
		碰到第一个非整数字符，停止转换。
		遇到小数点后面没有数据或是0，转成整数
		小数点前无数据也可转
	4. Number()
		将一个数据解析为number类型
		如果数据中包含非法字符，返回NaN
		undefined -> NaN
		null -> 0
关系（比较）运算符：
	<,>,<=,>=
	关系表达式计算的值都是boolean类型
	特殊注意：
		1. 字符串和数字比较大小关系时，现将字符串通过Number函数转换为数字再比较
		2. 字符串和字符串比较大小关系，比较的是每位字符的Unicode码
		3. NaN参与比较时，结果一律为false
表达式由操作数和运算符构成，只要是有值的就是表达式，常量是常量表达式
舍入误差问题
	toFixed(2) 四舍五入，保留两位小数
短路逻辑
	1. && (逻辑与)
		如果第一个表达式的结果为false，那么第二个表达式就不用再判断，整个表达式的结果为false
		如果第一个表达式的结果为true，则继续判断第二个表达式的结果，并且以第二个表达式执行结果作为整个逻辑表达式的结果
	2. || (逻辑或)
		如果第一个表达式的结果为true的话，不继续执行第二个表达式，并且将true作为整个逻辑表达式的结果
		如果第一个表达式结果为false，继续执行第二个表达式，并且将第二个表达式的计算结果作为逻辑表达式的结果
位运算：
	只能做数字运算，运算的数字（小数会转为整数）先转2进制再运算，和逻辑运算不同！
	1. & 按位与
		将两边的操作数转换为二进制，每位的数字，只有对应都为1的时候，该位的结果才为1，否则该位的结果就是0
		作用：判断一个数字的奇偶性，数字与1按位与
	2. | 按位或
		两边操作数转二进制，比较每位数字，两个数中有一个1时，该位结果为1否则为0
		作用：向下求整
	3. << 按位左移
		将二进制数向左移动几位，后面补0（相当于*2^n）
	4. >> 按位右移
		将二进制数向右移动几位，前面补0，去掉后面的几位（相当于*2^-n）
	5. ^ 异或
		将两边操作数转换为二进制，每位上的数字，只有一个为1时，该位结果为1，否则为0
赋值运算符：
	符号左边必须是变量
	赋值表达式的结果是等号右边表达式的值
	拓展：
		+= -= *= /= %= &= |= ^=
条件运算符（三目/三元 运算符）
	表达式1 ? 表达式2 : 表达式3;
	表达式1结果应该为boolean类型
	若表达式1为true，则整个表达式的值为表达式2的运算结果
	若表达式1为false，则整个表达式的值为表达式3的运算结果
	条件表达式允许被嵌套
内存空间的使用：
  栈：全局变量/局部变量
  堆：对象
函数：
	带参函数：function main(a,b,c){}
	形参是局部变量
	函数名是个变量，里面存的是函数体的地址
	按值传递：
		两变量赋值时，或将变量作为参数传入函数中时，其实仅将原变量中的值复制一个副本给对方
声明提前（hoist）：
	在程序开始执行前，都会先将var声明的变量和function声明的函数提前到当前作用域的顶部集中创建。（赋值留在原地）
变量声明提升：
  通过var声明定义的变量，在语句之前就可以访问到，值是undefined
函数声明提升：
  通过function定义的函数，在之前就能直接调用
先执行变量声明提升，再执行函数声明提升
全局执行上下文：
  在执行全局代码前将window确定为全局执行上下文
  对全局数据进行预处理
    var 定义的全局变量->undefined，添加为window的属性
    function 声明的全局函数，添加为window方法
    this -> 指向window
函数执行上下文
  调用函数，准备执行之前，创建对应的函数执行上下文对象(虚拟的，存于栈中)
  对局部数据进行预处理
    形参变量 -> 赋值实参，添加为执行上下文属性
    arguments -> 赋值实参列表，添加为执行上下文属性
    var 定义的局部变量 -> undefined，添加为执行上下文属性
    function声明的函数，添加为执行上下文方法
    this -> 指向调用函数的对象
变量的作用域：
	作用域就是变量与函数的可访问范围，它控制着函数与变量的可见性与生命周期
	作用域分为两种：
		函数作用域，又称为局部变量，只能在当前函数中访问，离开函数无法访问
		全局作用域，又称全局变量，一经定义，代码任何位置都可访问
		定义方式：
			1. 独立于所有函数作用域外的变量
			2. 声明变量时不加var关键字（注意：必须先调用变量所在的函数后才能继续使用）
	声明提前
		js程序在正式运行前，会将所有var声明的变量和function声明的函数，预读到所在作用域的顶部。但是对变量的赋值还保留在原有位置
	按值传递
		基本数据类型的数据，在作为实参传递时，实际上将参数的值复制了一份副本进行传递的
内存溢出：
  一种程序运行出现的错误，当程序运行需要的内存超过了剩余的内存
内存溢出：
  占用的内存没有及时释放
  内存泄漏积累多了就容易导致内存溢出
  常见的内存泄漏：1.意外的全局变量 2.没有及时清除计时器或回调函数 3.闭包
函数的作用域
	也分为全局作用域（全局函数）和函数作用域（局部函数）
	全局函数：
		声明在独立于任何function的位置处，位于js的最外层
	局部函数：
		在一个函数内部定义的函数
	常用的全局函数
		encodeURI() //对字符串进行URI编码
		decodeURI() //对字符串进行URI解码
    encodeURIComponent() //对字符串进行URI编码，包括特殊字符
    decodeURIComponent()
    escape() //对字符串编码
		isFinite() //判断数据是否有有限值
		eval() //计算并执行字符串表示的js代码
运算符的优先级（具有相同优先级的运算符按实际情况从左至右的顺序求值）：		
	. [] ()								字段访问、数组下标、函数调用以及表达式分组
	++ -- - ~ ! delete new typeof void	一元运算符、返回数据类型、对象创建、未定义值
	* / %								乘法、除法、取模
	+ - +								加法、减法、字符串连接
	<< >> >>>							移位
	< <= > >= instanceof				小于、小于等于、大于、大于等于、instanceof
	== != === !==						等于、不等于、严格相等、非严格相等
	&									按位与
	^									按位异或
	|									按位或
	&&									逻辑与
	||									逻辑或
	?:									条件
	= oP=								赋值、运算赋值
	,									多重求值
默认转为false的情况
	0 0.0 NaN undefined "" null
if(){} //如果大括号省略，只影响一条语句
switch(变量/表达式){
	case 值1:
		语句块1;
		break;
	case 值2:
	case 值3:
		语句块2;
		break;
	default:
		语句块;
}//如果在switch中写continue，不会作用在switch中，会作用在switch上面的循环结构中
for循环的表达式多样化
	1. for(var i=1,sum=0;i<=100;i++){}
	2. for(var i=0;i<=100&&sum>=50;i++){}
	3. for(var i=0;i<=100;i++,j++){}
数组：
	内存中连续存储多个数据的存储空间，一个统一名字，便于查找维护
	数组是变量的集合
	创建数组
		1. var a=[];
		2. var a=new Array();
	初始化数组
		1. var a=[1,2,3,4];
		2. var a=new Array(1,2,3,4);
	创建N个空元素数组
		var a=new Array(N);
	数组.length 是最大下标+1
	用数组的技巧
		1. 获取倒数第一个数据 a[a.length-1]
		2. 获取倒数第N个数据 a[a.length-n]
		3. 数组末尾追加新元素 a[a.length]="你好";
		4. 删除数组末尾元素 a.length--;
		5. 删除数组末尾N个元素 a.length-=n;
引用类型：
	一个变量只允许保存一个值
	引用类型的数据可以保存多个
	在Window之外，创建独立存储空间，每个空间都有一个唯一的地址值
	变量中仅保存地址值，称为引用
[]==[] 值为false的原因：
	[]代表创建了一个数组，创建两个数组地址值不一样，所以为false。因为没有引用，所以会被垃圾回收器销毁。
null和undefined
	只能从用法区分
	undefined专门由JavaScript语言自己使用，为变量自动赋初值。
	null专门给程序员使用，手动清除一个变量的内容。
	何时需要清空一个变量（何时使用null）：
		垃圾回收：js引擎会自动释放不再被任何变量引用的对象
		垃圾回收器：专门回收不再使用对象的小程序
			1. 记录每个对象被几个变量引用
				每多一个引用对象，计数器就+1。当变量赋值为null时，表示不再引用对象，计数器-1。
			2. 回收不再被任何变量引用的对象
				当计数器变为0时，对象就被垃圾回收器回收
		何时需要清空变量：
			只要一个变量引用的大对象不再使用时，都要主动清空变量
			为了节约内存
			使用完一个较大的对象时，主动清空总是好习惯
		null和undefined都可以这么用
关联数组：
	可自定义下标名称的数组，对应的是索引数组
	为什么使用：为了让每个数据都有明确的意义
		1. 便于维护和读取
		2. 查找方便
	创建：
		第一步：创建空数组
		第二部：向数组中添加新元素，使用自定义下标名称
	访问：
		用法和下标数组一样
	遍历：
		for(var key in arr){} //依次取出arr数组的每个下标名称存入key中
	关联数组也叫键值对集合
数组API：
	转字符串：
		1. String(arr) 将数组每个元素都转为字符串，再用逗号连接（对数组拍照）
		2. arr.join("自定义连接符") 将数组中每个元素转为字符串，可自定义连接符（不写默认是逗号分隔），用空字符串会无缝拼接
	拼接和选取：
		concat 拼接：将其他元素或另一个数组，拼接到当前数组结尾
			newArr=arr.concat(值1,值2,arr2); 可以是值，也可以是数组。
			强调：
				1. 此方法无权修改原数组，只会返回新数组，只能用新数组接着
				2. 它会打散参数中的子数组为单个元素，单个拼接
		slice 选取：获取原数组中指定位置开始到结束位置之间的所有元素，组成临时子数组
			newArry=arr.slice(starti,endi+1); 选取starti位置开始到endi位置的所有元素，组成临时字数组
			例子：
				arr.slice(3,6); 表示选取3,4,5号元素
			强调：
				1. 无权修改原数组，只是复制原数组中的元素组成新数组
				2. 含头不含尾：当两个参数都是下标时，开始下标的元素包含在结果中，结束下标的元素不包含结果中
			简写：
				1. 支持负数参数，表示倒数第N个位置（-n，相当于length-1）
				2. 省略第二个参数，表示从指定位置一直截取到结尾
				3. 两个参数都省略，表示完整复制整个数组
	splice 修改（删除，插入，替换）：
		删除：arr.splice(starti,n) 删除arr中starti开始的N个元素
			强调：
				1. 直接修改原数组
				2. 不考虑含头不含尾
			返回值：被删除元素组成临时字数组
			简写：splice也支持负数
		插入：arr.splice(starti,0,值1,值2,……)
			将值1,值2,……插入到arr中starti位置，原位置的值向后顺移
			0表示一个也不删，只插入
			强调：
				不会打散数组，整个数组保存在一个元素中
		替换：arr.splice(starti,n,值1,值2,……)
			先删除arr中starti位置开始的n个元素，再插入值1，值2
	排序API：
		arr.sort()
		问题：默认仅支持按字符串升序排列
		解决：自定义比较器函数
			什么是比较器函数：专门比较任意两值大小值的函数
			第一步：
				要求：2个参数（a,b）
						返回值：如果a>b，返回正数
								如果a<b，返回负数
								否者，返回0
				最简单的比较器函数: function cmp(a,b){return a-b}
			第二步：
				将比较器函数返回对象 arr.sort(cmp);
	翻转数组：arr.reverse()
		强调：
			1. 直接修改原数组
			2. 不负责排序，仅原样颠倒数组
	栈和队列：js没有专门的栈和队列类型，都是普通数组模拟
		只要希望按照一定的顺序访问数组中的元素时
		始终使用最新的数据
		栈stack：一端封闭，只能从另一端进出的数组
			1. 结尾出入栈：
				入：arr.push(值) //数组末尾插入值
				出：arr.pop() //删除末尾数组元素并返回
				特点：每次出入栈，剩余元素位置不受影响
			2. 开头出入栈：
				入：arr.unshift(值) //数组开头插入值
				出：arr.shift() //删除开头数组的值并返回
				特点：每次出入栈，都会导致剩余元素位置改变
			开头出入栈结果和结尾出入栈结果相反
		队列queue：只能从一端进入，一端出的数组
			只要希望按照先来后到的顺序访问数组元素时
			结尾入：arr.push(值)
			开头出：arr.shift()
	判断：
		arr.every() //判断arr中每个元素是否都符合要求
			只有每个元素都符合条件时，才返回true
			只要有一个元素不符合条件就返回false
		arr.some() //判断arr中每个元素是否都符合要求
			只要有一个元素符合条件就返回true
			所有条件都不符合，返回false
		用法：
			arr.every(function(val,i,arr){
				//val会自动获得当前元素值
				//i自动获得当前元素的位置
				//arr自动获得当前数组
				return //条件
			});
			every会用function取每个元素执行一次，收集true和false
		遍历：
			arr.forEach(function(val,i,arr){}) //对原数组中每个元素执行相同的操作，直接修改原数组
			var newArr=arr.map() //取出原数组中的值经过加工后放入新数组，不直接修改原数组
		选取和过滤：
			过滤：选取原数组中符合条件的元素组成新数组
			arr.filter(function(val,i,arr){
				return //条件
			});
			汇总：对数组中每个元素的值最终统计出一个新的结果
			var result=arr.reduce(function(prev,val,i,arr){
				//prev获得截止目前的统计结果
			},start);
二维数组：
	数组中的元素又引用了另一个字数组
	何时使用：
		1. 存储横行竖列时使用
		2. 需要对一个大数组中的元素进行细致分类时
	如何使用：
		1. 在创建数组同时，初始化字数组
			var data=[
				[0,0,0,0],
				[1,1,1,1],
				[2,2,2,2]
			];
		2. 先创建空数组，再添加字数组
			var data=[];
			data[0]=[0,0,0,0];
			data[1]=[1,1,1,1];
			data[2]=[2,2,2,2];
		3. 访问元素
			强调：二维数组的行下标不能越界，否则报错
				例子：arr[2][3];
				原因：如果arr数组2号元素不存在，会返回undefined，但是如果访问undefined[3]就会报错（undefined和null后面不能加 . {} [] () 等）
		4. 遍历：
			外层循环控制行，内层循环控制列
字符串 String：
	什么是字符串：
		由多个字符组成的字符只读数组
	VS数组：
		相同：
		1. 都能用下标访问每个元素/字符
		2. 都有length属性记录元素/字符个数
		3. 都能用for循环遍历每个元素/字符
		4. 都支持slice选取子数组/子字符串
		不同：
		1. 数组可随意修改原数组，但字符串是只读字符数组，一旦创建内容，不可改变
		2. 类型不同：数组是Array类型，字符串是String类型
			         两者API不通用！
	所有字符串API不能修改原字符串，只能返回新字符串
	查看字符的UNicode编码
		"好".charCodeAt()
		"好".charCodeAt().toString(2) 转2进制
		16进制转字符串 console.log("\u5f20");
	大小写转换：
		str.toLowerCase() //转小写
		str.toUpperCase() //转大写
		只要不区分大小写时，都要先转为一致的大小写，再判断或比较
	获得指定位置的字符：
		str.charAt(i) 等价于 str[i]
	获得指定位置字符的Unicode号：
		str.charCodeAt(i) //i是数组下标，截取一个字符，默认是0，返回Unicode号
	将Unicode转回正文
		var char=String.fromCharCode(unicode)
	选取字符串：
		str.substring(starti,endi+1); //和截取数组一样，slice
			不支持负数参数，变通：arr.length-n
			省略第二个参数，一直选取到结尾
		str.substr(starti,n) //选取starti开始的n个元素
	检索关键词：
		查找出字符串中包含的敏感词的位置和内容
		1. 检索一个固定的关键词出现的位置
			var a=str.indexOf("关键词")
			强调：1.默认从0开始
				  2.默认找到第一个就不找了
			从指定位置开始找下一个，默认是0
				var a=str.indexOf("关键词",i)
			找不到返回-1
			固定套路：找所有关键词位置
				var i=-1;
				while((i=str.indexOf('关键词',i+1))!=-1){
					i//本次关键词位置
				}
			查找最后一个关键词的位置
				var a=str.lastIndexOf("关键词");
			问题：只能查找一种固定的关键词
			解决：正则表达式（在线测试 https://regex101.com/#javascript）
		2. 判断字符串中是否包含符合正则的敏感词
			var str.search(/正则/)
			查找str中符合正则要求的敏感词的位置i
			如果找不到返回-1
			比如：判断str中是否包含"微信" str.search(/微信/)
			问题：仅能返回位置，无法返回内容。仅能找第一个关键词（不支持g），无法向后找
		3. 返回所有关键词的内容：
			var arr=str.match(/正则/)
			查找str中所有符合正则表达式要求的关键词，保存在一个数组中返回
			强调：如果没找到返回null
				如果有可能获得null，就必须先验证不是null再使用
			问题：正则默认仅匹配第一个关键词，区分大小写
			解决：找全部 /g  忽略大小写 /i   str.match(/正则/gi)
			问题：只能返回每个关键词的内容，无法返回位置，只能匹配大正则，小括号里面的无法匹配
		4. 替换：将所有关键词替换成新的内容
			简单的：所有关键词都替换为统一的内容
			str.replace(/正则/gi,"新值")
			衍生操作：
				1. 删除：替换为空字符串就是删除
				2. 格式化：将原字符串中的关键词按新的格式重新组合
					1. 用正则将原字符中的内容分组
					2. 用replace按新格式重新组合各个分组的内容，每个分组都有一个序号，从1开始用$1选取
					比如：19980212
					birth.replace(/(\d{4})(\d{2})(\d{2})/,"$1年$2月$3日");
					其中：$n可获得第N个分组对应的子字符串
			强调：1. replace无权修改原字符串，必须用变量接住
		 高级替换：
			根据不同的关键词，动态替换不同的新值
			str=str.replace(/正则/gi,function(kw){
				kw//本次找的关键词
				//return 根据kw计算出新的替换值
				return (kw.length==2)?"**":"***";
			})
		5. 字符串切割：将字符串按指定的分隔符，分隔为数组
			var arr=str.split(/正则/)
			比如：将邮箱地址切割为用户名和域名
				var arr=mail.split(/@/);
				arr[0] 是用户名
				arr[1] 是域名
			固定套路：
				1. 将字符串打散为字符数组 var arr=str.split("")
				2. 将页面元素转化为数组
EegExp对象：
	什么是：封装一条正则表达式，并提供使用正则执行验证和查找的API
	何时：
		1. 用正则表达式验证字符串格式时
		2. 即查找每个关键词的内容，又查找每个关键词的位置
	创建：
		1. 使用直接量 var reg=/正则/ig;
			如果正则表达式是 固定的
			强调： / 转为 \/
		2. 使用new
			var reg=new RegExp("正则","ig");
			如果正则表达式需要动态生成
			强调： "转为\"   \d转为\\d
	验证：检查输入的字符串是否符合正则表达式的要求
		var bool=reg.test(str);
		验证str是否满足reg的要求，满足返回true，否则返回false
		reg预先定义好，判断字符串是不是符合reg定义的格式
		问题：默认情况下只要str中部分满足reg的要求就返回true
		解决：凡是验证，必须前加^后加$
			  要求必须从头到尾，必须完整匹配
	查找关键词并返回位置：
		var arr=reg.exec(str)
		在str中查找符合reg要求的下一个关键词
		返回值：arr[0:本次找到的关键词,index:本次找到的关键词位置]
		如果找不到，返回null，必须先验证不是null再验证
		找所有关键词并返回
			while(arr=reg.exec(str)){
				console.log(`在位置${?}发现敏感词${?}`);
				//es6新特性 ${变量} 可以直接输出
				// ` 是反引号，在数字1左边
			}
		每次执行，它有个属性reg.lastIndex会用当前索引加字符的length
		如果分组，就把数据加入索引中 比如：[1]
		RegExp.$n可获得本次找到的第N个分组的子内容
内置对象：ES标准中规定的，浏览器厂商已经实现的对象
	有11个：
	String Number Boolean
	Array RegExp Date Math
	Error
	Function Object
	Global（全局，在浏览器中被window代替了）
包装类型：
	String Number Boolean ……
	什么是：专门封装原始类型的值，并提供操作原始类型值的APi
	为什么：原始类型的值本身没有任何功能！必须借助外部的对象提供功能才行
	何时：只要对原始类型的值调用API时，自动创建包装类型来辅助原始类型的值完成操作
	如何用：不用手动创建和调用，都是自动创建和调用
		比如：n.toFixed(2) 等效于 new Number(n).toFixed(2)
				toFixed执行后，Number对象释放
			  "章".charCodeAt() 等效于 new String("章").charCodeAt()
debugger; //用于调试，打开F12可以用
Math对象：
	不能用new，都是直接使用
	1. 取整：
		上取整：Math.ceil(num);  Math.ceil(3.4) => 4
		下取整：Math.floor(num);
			Math.floor(6.5) => 6
			和parseInt的比较
			参数是数字两者无差别
			参数是非数字字符的字符串
				parseInt("12.5px");  12 //将数据转为字符串类型（String）再按位读字符
				Math.floor("12.5px"); NaN //将数据转为数字类型（Number），再截取
		四舍五入取整：Math.round(num);
			和toFixed比较
			1. round只能取整，toFixed可按任意小数位数四舍五入
			2. round返回是数字，可直接做加减。toFixed返回字符串
	2. 乘方和开方
		乘方：Math.pow(底数，幂)
		开平方：Math.sqrt(num)
	3. 最大值和最小值: 
      Math.max(值1,值2,...); 
      Math.min(值1,值2,...);
        问题: 不支持数组
        解决: Math.max.apply(null,arr)
    4. 随机数: 
        Math.random()  0<=r<1 随机小数
        从min~max之间取随机整数: 
        Math.floor(Math.random()*(max-min+1)+min)
        从0~n之间取随机: 
        Math.round(Math.random()*n);
Date对象：
	日期对象中存储的是1970年1月1日0点至今的毫秒数
		取出毫秒数：var ms=date.getTime();
	获得客户端当前系统时间：var now=new Date();
	创建日期对象保存自定义时间：
		var date=new Date("yyyy/MM/dd hh:mm:ss");
	复制日期对象：
		日期的计算都是直接修改原日期对象，计算后，原日期无法保留
		只要需要同时保存开始和结束时间时，都要先将开始时间复制一个副本，再用副本计算
		var date2=new Date(date1)
	用毫秒创建时间：
		var date=new Date(ms);
		数据库存时间都用ms，数据库中ms被查询到客户端，需要转为时间
	Date对象的API：
		getFullYear getMonth getDay  getDate  //年月星期 一个月的第几天
		getHours getMinutes getSeconds getMilliseconds //时分秒 毫秒
		只有月份Month需要修正，其余都不用修正
	两日期对象直接相减，得到毫秒差，可用于倒计时
	对任意单位做加减：date.setXXX(date.getXXX()+n)
		强调：直接修改原对象，setXXX()可自动调整时间进制
	格式化：
		toString 当地标准时间完整格式（+8区）
		toLocaleString 当地时间的简化版格式
		toLocaleDateString 当时时间格式仅保留日期部分
		toLocaleTimeString 当时时间格式仅保留时间部分
		toGMTString 国际标准时间（0时区）
错误处理（bug）：
	在程序执行过程性中造成异常中断的原因
	发生错误：程序会中断退出
	错误处理：及时发生错误，也能保证程序不异常中断的机制
		try{
			//可能出错的代码
		}catch(err){//err是一个形参
			//错误的处理代码
			//1. 记录日志 2. 提示用户
		}finally{
			//无论是否发生错误都必须执行的代码
			//释放资源
		}
	一旦出错就自动创建Error对象
Error对象：
	发生错误时，自动创建的，封装错误信息的对象
	包括6类：
		SyntaxError 语法错误
		ReferenceError 引用错误，要用的变量未找到时
		TypeError 类型错误（错误使用类型，错误调用类型方法）
		RangeError 范围错误 参数超范围
		URIError，EvalError
	主动抛出错误：在框架级开发时，API要想保护自己，告诉调用者错误使用API，都要通过抛出自定义错误
		throw new Error("错误");
关于效率：
	放入try…catch代码中的效率会比外降低
	解决：如果错误是可以提前预知的，可用if…else代替
Function函数对象：
	实现特定功能的n条语句的封装体
  只有函数可以执行，其他类型的数据不能执行
  便于阅读，提高复用率
	本质：一个封装代码段的对象
		函数名只是一个引用函数对象的变量
	如果函数名或变量名重复，不会再创建变量，会直接引用地址或赋值
	定义函数：
		1. 声明 function fun(形参){//函数体; return //返回值}
			会被声明提前
		2. 直接量 var fun=function(){}
			不会被声明提前
		3. 用new创建：var fun=new Function("参数","函数体","返回值");//强调：所有形参必须放在引号中
	笔试题：
		以下创建函数正确的是
		function cmp(a,b){return a-b} //right
		var cmp=function(a,b){return a-b} //right
		var cmp=new Function(a,b,"return a-b") //wrong
		var cmp=new Function("a","b","return a-b") //right
	判断实例是不是属于某个类
		f instanceof Fn;//返回布尔值
重载overload：
	根据函数名，不同函数列表的多个函数，在调用时，可自动根据传入参数的不同，调用对应的函数执行
	减轻调用者的负担
	只要一项任务根据不同的参数执行不同的流程时
	js不支持重载。不允许多个同名函数存在
	js可以重写
	解决：arguments对象
		arguments是每个函数中自带的接受所有传入参数值的类数组对象
		类数组对象：长到想数组的对象
			和数组比较：
				1. 都能用下标
				2. 都有length属性
				3. 类型不同：arguments是Object类型，不能用数组API
匿名函数：
	函数创建时，不指定函数名的函数
	为了节约内存
	只要一个函数仅执行一次时，必须用匿名函数
	两种方法：
		1. 回调函数：
			arr.sort(function(a,b){return a-b})
		2. 自调函数：创建函数后立刻调用
			如果一段代码不希望其中的变量造成全局污染时，就要放在匿名函数中自调
			1. +function(){}()
			2. (function(){})();
作用域和作用域链：
	作用域（scope）：一个变量的可用范围
	包括两种：
		1. 全局作用域对象window：全局变量
			全局变量：随处可用，可反复使用——全局污染
		2. 函数作用域对象AO(活动对象)：局部变量
			局部变量：仅函数内可用，不可重复使用
	函数生命周期：
		1. 开始执行前
			创建执行环境栈（数组）ECS：临时保存正在执行的函数的执行环境
			向执行环境栈中压入第一个默认函数main()
			创建全局作用域对象window
		2. 定义函数时
			创建函数对象，封装函数定义
			声明函数名变量，引用函数对象
			函数对象的scope属性引用回创建函数时的作用域
		3. 调用函数时
			ECS中压入一个新的元素（执行环境）记录新函数的调用
			创建一个活动对象（函数作用域对象），保存本次函数调用用到的局部变量
			ECS中的执行环境元素引用活动对象（包括形参，局部变量）
			活动对象中的parent属性引用函数的scope指向的父级作用域对象
			执行过程中优先使用活动对象中的局部变量，如果局部没有才延parent向父级作用域中找
		4. 函数调用后
			执行环境栈中本次函数的执行环境出栈
				导致活动对象被释放
				导致局部变量一同释放
	作用域链：由多级作用域连续	引用形成的链式结果
		掌管着一切变量的使用顺序：
		先在局部找，没有就延作用域链向父级作用域找
闭包：
	即重用变量，又保护变量不被污染的一种机制
		全局变量 优点：反复使用。缺点：随处可用（全局污染）
		局部变量 优点：仅函数内可用。缺点：不可重用
	如果希望即重用变量，又保护变量不被污染，用闭包
	3步：
		1. 用外层函数包裹受保护的变量和操作变量的内层函数
		2. 外层函数将内层函数返回
		3. 使用者调用外层函数获得内层函数的对象
	闭包如何形成：外层作用域的对象（AO）无法释放
	缺点：比一般函数占用更多内存
	闭包不释放就是 内存泄露
	释放闭包：将引用内层对象的全局变量赋值为null
	笔试时画简图：
		1. 先找受保护的变量，确定外层函数调用后，受保护变量的最终值
		2. 再找操作变量的内层函数
			1. 被外层函数return到外部的
			2. 也可直接给全局变量赋值一个函数抛出
OOP（面向对象）：
	程序中都是用对象来描述现实中一个具体事物
	对象：封装一个事物的属性和功能的程序结构
	便于大程序的维护
	只要使用OOP，都要现将事物的属性和功能封装在一个对象中，再反复使用对象的功能
	属性和方法统称为对象的成员
	js中一切对象底层都是关联数组！
		obj.属性 => obj["属性"]
		console.dir(obj) 存储结构和关联数组是完全一样的
  对象的属性是字符串（可以包含特殊字符）
	判断对象中是否有某个属性
		对象.属性名 !== undefined
		"属性名" in 对象
		对象.hasOwnProperty("属性名")
	如果对象方法想访问自己的属性，使用this
		this是引用正在调用函数的对象的关键词，简单说就是.前的对象
	面向对象三大特点：封装，继承，多态
		封装：将一个事物的属性和功能集中定义在一个对象中
			  便于大程序的维护
			  只要使用OOP，都要先将事物的属性和功能封装在一个对象中，再反复使用对象的功能
			如何封装：事物的属性会称为对象的属性，事物的功能会称为对象的方法
				1. 对象直接量
					var obj={属性名:属性值,方法名:function(){}}
					在创建对象时就知道对象成员
				2. 用new创建：
					var obj=new Object();
					创建对象时，暂时不知道对象成员
					简写new Object() => new Object 或　Object()
				以上问题：仅能封装一个单独的对象
				解决：构造函数
				3. 构造函数
					描述一类对象统一结构的函数
					只要反复创建多个相同结构的对象时，都要先定义统一的构造函数，再使用构造函数反复创建对象
					1. 定义构造函数描述统一结构（constructor）
						function 类型名(属性参数){
							this.属性名="";
							this.方法名=function(){
								this.属性……
							}
						}
					new干了4件事：
						1. 创建一个空对象
						2. 让新对象继承构造函数的原型对象：设置新对象的__proto__指向构造函数的prototype
						3. 用空对象调用构造函数：将构造函数中的this指向空对象
						4. 返回新对象的地址
					优点：代码重用
					缺点：无法节约内存
					解决：继承
			强调：js对象即使创建完成，仍然可以添加新成员
		继承：父对象的成员，子对象无需重复创建就可直接使用
			好处：代码重用，节约内存
			今后只要多个子对象拥有相同的属性值和功能，可用继承
			都要将相同的属性和功能集中保存在父对象中一份即可，所有子对象公用！
			js中的继承都是继承原型对象
				什么是原型对象：专门集中存储一类子对象相同属性值和功能的父对象
				今后只要一类子对象共有的相同属性值和功能都要定义在原型对象中
				原型对象买一赠一：每创建一个构造函数都会自动赠送一个原型对象
			原型对象：用new创建子对象时，会自动设置子对象的__proto__继承构造函数的prototype
			如何向原型对象中添加共有成员
				构造函数.prototype.属性=值;
				构造函数.prototype.方法=function(){};
			自有属性和共有属性：
				自有属性：直接保存在对象本地的属性
				共有属性：保存在原型对象中，被所有子对象共有的属性
				获取时：都可用对象.属性的方式获取
				赋值时：自有属性 对象.属性=值
						共有属性 构造函数.prototype.属性=值;
			鉴别自有还是共有：
				自有：var bool=obj.hasOwnProperty("属性名")
					  判断"属性名"是否是obj的自有属性
				共有：不是自有，且obj.属性名!==undefined
					  也可以用in var bool="属性名" in obj;
					  in 判断obj自己或obj的父对象中是否包含属性名，只要自己或父对象中包含，就返回true
			内置对象的继承关系：
				1. 凡是可以new的类型，都是构造函数
				2. 每个内置对象的构造函数都对应一个内置的原型对象
				3. 内置类型的原型对象中保存着该类型所有子对象共用API
				可解决浏览器兼容性问题：
					如果一个API新浏览器支持，旧浏览器不支持
					解决：if(typeof 内置对象.prototype/API != "function"){
						内置对象.prototype/API=function(){
							//this表示将来调用API的.前的对象
						}
					}
		多态：同一事物在不同情况下表现出不同的状态
			重写override：如果子对象觉得父对象成员不好用，可以在子对象本地定义同名成员，覆盖父对象的成员
			体现子对象与父对象之间的差异和个性化
			只要子对象觉得父对象中的成员不好用，就可在本地重写父对象的成员
		自定义继承：
			1. 仅设置两个对象间的继承关系：
				child.__proto__=father
				问题：__proto__也是内部属性，有可能被浏览器禁用
				解决：API Object.setPrototypeOf(child,father);
			2. 批量设置多个子对象的继承关系
				只要修改构造函数的prototype对象即可
				构造函数.prototype=father
				定义完构造函数之后，立刻设置原型对象
			3. 两种类型间的继承
				如果发现多个类型之间拥有相同的属性结构和方法时，就要抽象出一个父类型
				1. 定义父类型：
					父类型的构造函数，集中定义相同的属性结构
					父类型的原型对象，集中定义相同的方法				
				2. 让子类型原型对象继承父类型原型对象
					结果：保证子对象可调用父类型原型对象中的方法
				3. 在子类型构造函数中借用父类型构造函数
					结果：请父类型构造函数帮助构建共有的属性结构
					问题：直接调用父类型构造函数，其中this默认指window
					解决：call 只要this不是想要的，就可用call进行替换	
							父类型构造.call(this,参数)
							apply同理，可以把参数作为数组传入，自动打散
							父类型构造.apply(this,arguments);
JSON.stringify()将对象、数组转换成字符串；JSON.parse()将字符串转成json对象。
prototype属性：
  1.每个函数都有一个prototype属性，它默认指向一个Object空对象(即成为：原型对象)
  2.原型对象中都有一个属性constructor，它指向函数对象
显示原型和隐式原型：
  每个函数function都有一个prototype，即显示原型
    定义函数时自动添加的，默认值是一个空的Object对象
  每个实例对象都有一个__proto__，即隐式原型
    创建对象时自动添加的，默认值是构造函数的prototype属性值
  对象的隐式原型的值为其构造函数的显示原型的值
  程序员能直接操作prototype，但不能直接操作__proto__
原型链：
	访问一个对象的属性时，现在自身属性中查找，找到返回
  如果没有，再沿着__proto__(隐式原型链)这条链向上查找，找到返回
  最终没有找到，返回undefined
  原型链的作用：查找对象的属性
  实例对象的隐式原型等于构造函数的显示原型
  函数的显示原型的对象默认是空的Object实例对象(但Object不满足)
  所有函数都是Function的实例(包括它本身)
	VS作用域链：控制着变量的使用顺序
					优先使用AO中的局部变量，局部没有，才沿作用域向父级作用域查找
					作用域终点：window
	简单概况：所有不需要"对象".访问的变量，都保存在作用域链中
			  所有必须用"对象".访问的成员都保存在原型链中
	笔试题：判断一个对象是不是数组！有几种办法？
			0. typeof //不行，只能识别原始类型，function，object，无法进一步识别object不同对象类型
			1. 验证原型对象：
				//如果一个对象的原型对象是Array.prototype
				1. Object.getPrototypeOf(obj)==Array.prototype
				2. var bool=father.isPrototypeOf(child) //判断father是否是child父对象
			2. 验证构造函数：
				//如果一个对象的构造函数是Array
				1. obj.constructor==Array
				2. var bool=obj instanceof Array 判断obj是否由构造函数Array创建出来
					instance实例，一个类型中的一个具体的对象
					实例化：用new创建一个对象
			问题：验证不够严格，即使创建时不是用数组创建的，只要原型链上有数组类型，也认为是数组类型对象
			3.	检查内部属性class：
				class是每个对象中记录对象创建时使用的类型的属性
				一旦对象被创建，class属性无法被修改
				唯一办法：调用Object.prototype中的toString()
					输出结果：[object Object]
							object:引用类型对象
							Object:class属性
				问题：几乎所有内置对象的原型对象都重写了Object中的toString方法，所有内置对象的子对象都无法调到Object的toSting方法
				解决：call 任意对象.任意方法.call(任意对象)
				Object.prototype.toString.call(arr)
			4. Array.isArray(obj) //ES5
			自创方法：判断他们有没有length
bind()函数：
	基于一个现有函数，创建一个新函数，并永久绑定this
		不但永久绑定this，还可以绑定参数
	因为this总是发生变化，所以使用bind
	只要希望将一个对象永久绑定在一个函数内的this上
	结果：函数中的this将永远无法被其他对象替换
严格模式：比普通js更严格的执行模式
	几乎所有新项目都要用严格模式
	1. 新项目：在每个js文件开头"use strict";
		让整个js文件启用严格模式
	2.旧项目：逐个函数启用严格模式
		在函数体的开头"use strict";
	作用：
		1. 静默失败升级为错误
		2. 禁止使用未声明的变量
		3. arguments不再建议使用
保护对象：
	js中对象的普通属性随时可被修改为任何值，随时可添加新属性，随时可被删除
	1. 保护属性：
		命名属性：可用.访问到的属性
			数据属性：直接存储属性值的属性
				每个属性都有四大特性：
					value：实际存储属性值
					writable：是否可修改 默认为true
					enumerable：是否可被for in遍历到（仅能控制 for in 无法看到.的访问） 默认true
					configurable：
							是否可修改其writeble或enumerable（不可逆）
							是否可删除该属性
				获得属性的四大特性API：
					var attrs=Object.getOwnPropertyDescriptor(obj,"属性");
				更改四大特性：
					Object.defineProperty(obj,"属性",{
						writeble:false
					});
					问题：一次只能修改一个属性的四大属性
					解决：同时修改多个属性的四大特性
						Object.defineProperties(obj,{
							属性:{特性:值,……},
							……
						});
					如果修改属性不存在会自动创建
						问题：通过defineProperty添加的属性四大特性默认都为false
					通过对象直接量添加的属性，默认四大特性都为true
					问题：四大特性只能对属性提供基本保护
						如何使用自定义规则保护属性（访问器属性）
			访问器属性：不直接存储属性值，专门对其他属性提供保护的特殊属性
				数据属性的四大特性无法使用自定义规则保护属性
				只要使用自定义规则保护属性规则时，要用自定义逻辑
				1. 定义一个闭包实际存储属性值
				2. 定义一个访问器属性来保护闭包中的局部变量
					var obj={num:0};
					(function(){
						var _num;
						Object.defineProperty(obj,"num",{
							get:function(){
								return _num;
							},
							set:function(val){
								if(val<=0){
									throw new Error("数不能小于等于0");
								}
								else{
									_num=val;
								}
							}
						});
					})();//get和set都是固定的
			对于构造函数（对象模板）的保护：
				function moban(a,b,c,d){
					this.a=a;
					this.b=b;
					this.c=c;
					var _d; //不需要匿名函数
					Object.defineProperties(this,{
						a:{writable:false,configurable:false},
						b:{configurable:false},
						c:{enumerable:false,configurable:false}
						d:{
							get:function(){
								return _d;
							},
							set:function(val){
								if(val<=0){
									throw new Error("不能为0");
								}else{
									_d=val;
								}
							}
						}
					});
				}
		内部属性：不允许用.访问的属性
			class __proto__
	2. 保护整个对象：防篡改
		1. 防扩展：禁止向对象中添加新属性
			Object.preventExtensions(obj);
		2. 密封：既防扩展，又禁止删除任何属性
			Object.seal();
				防拓展
				将所有属性的configurable设置为false
		3. 冻结：即防扩展，又禁止删除，同时禁止修改一切值
			Object.freeze(obj);
Object.create():
	基于一个父对象创建一个子对象，并为子对象扩展新属性
	var obj=Object.create(father,{
		属性:{value:1,……},
		属性:{value:1,……}
	});
方法定义在构造函数和原型对象的区别
	定义在原型对象中，所有实例化的子对象都可使用
	定义在构造函数中，不需要任何子对象，就可直接用
	继承father对象：
		function f(){};
		f.prototype=father;
		var obj=new f();
		f=null;
正则表达式：
	什么是：规定一个字符串中字符出现规律的表达式
	何时：只要使用一种规则，模糊匹配关键词时
	如何：
		1. 最简单的正则就是关键词原文，转义字符\
		2. 字符集：规定字符串中某一位字符，备选字符列表
			何时：只要一位字符，有多种备选字符时
			如何：[备选字符列表]
			强调：1. 每个字符集只能匹配一个字符
				  2. 每个字符集至少匹配一个
			简写：1. 如果备选字符列表是连续的，可用"-"省略中间字符
					比如：一个数字:[0123456789]等价于[0-9]
						  一位小写字母:[a-z]
						  一位字母:[A-Za-z]
						  一位汉字：[\u4e00-\u9fa5]
			特殊：除了XXX之外 [^XXX]
		3. 预定义字符集：对常用字符集的简写
			问题：只有需求和预定义字符集完全匹配时才能使用
			解决：自定义字符集：一位字母或数字 [A-Za-z0-9]
			一位数字：\d等价于[0-9]
			一位字母，数字或下划线：\w等价于[A-Za-z0-9_]
			一位空字符(tab 回车 空格，一切看不见的字符)：\s
			任意字符：.
			问题：一个字符集只能匹配一位，仅用于规定字符的内容，无法规定字符出现的次数
			解决：量词
		4. 量词：专门规定一位字符集出现次数的规则
			量词都用于一个字符集之后，修饰相邻的前一个字符集
			1. 有明确边界：
				1. 字符集{n,m} 字符集连续出现最少n次，最多m次
				2. 字符集{n,} 字符集连续出现最少n次，多了不限
				3. 字符集{n} 只能连续出现n次，不能多也不能少
			2. 没有明确边界：
				我[]?  表示匹配"我"这个字，还可以匹配"我"加上字符集中的字（只包括一个）
				我[]*  表示匹配"我"这个字，还可以匹配"我"加上字符集中的字（包括不限制）
				我[]+  表示匹配字符集中的字，没有就不匹配，只要有就匹配，多了不限制		
		5. 选择和分组：
			选择：规则1|规则2  满足规则1或规则2之一即可
			分组：(规则1规则2)
				何时：只要希望一个量词可以同时修饰多个字符集时
		6. 匹配指定位置：
			字符串开头 ^  比如：^\s+ 开头的空字符
			字符串结尾 $  比如：\s+$ 结尾的空字符
			单词边界 \b  包括：^ $ 标点 空格
	贪婪模式：正则表达式默认总是匹配尽量长的字符串
	懒惰模式：让正则表达式仅匹配最短条件的子字符串
		贪婪改懒惰两种方法
			1.  .*.+ => .*?.+?
			2. [^XXX]*
	正则表达式补充：
		正则表达式用来处理字符串的一个规则
		每个正则表达式都是由元字符和修饰符组成的
			元字符：在//之间具有意义的一些字符
			1. 具有特殊意义的元字符
				\ 转义字符，转义后面字符所代表的含义
				^ 以某一个元字符开始
				$ 以某一个元字符结尾
				\n 匹配一个换行符
				. 除了\n以外的代表全部字符
				() 分组 把一个大正则划分成几个小正则
				   改变x|y默认的优先级
				x|y x或y中的一个
				[xyz] x或者y或者z中的一个
				[^xyz] 除了三个中的任何一个字符
				[a-z] a-z之间的任何一个字符
				[^a-z] 除了a-z之间的任何一个字符
				\d 一个0-9之间的数字
				\D 除了0-9之间的数字
				\b 一个边界符，不是字母的符号
				\w 数字，字母，下划线中任意字符
				\s 匹配一个空白字符，空格，一个制表符，换页符
			2. 代表出现次数的量词元字符
				* 出现0到多次
				+ 出现1到多次
				? 出现0次或者1次
				{n} 出现N次
				{n,} 出现N到多次
				{n,m} 出现N到M次
				[]: 在中括号中出现的所有字符都是代表本身意思的字符，没有特殊含义，不识别两位数	
			3. 修饰符：g i m
				global(g) 全局匹配
				ignorecase(i) 忽略大小写
				multiline(m) 多行匹配
			?在正则中有很多作用：
				1. 放在一个普通的元字符后面代表出现0-1次 // \d? 出现0-1次数字
				2. 放在一个量词元字符后面是取消捕获时候的贪婪性
DOM:document object model
	专门操作网页内容的API
	DOM tree：网页中一切内容在内容中都是以树形结构存储的
		为什么：树形结构证明储存上下级包含关系最直观的结构
		树根：document对象
			所有网页内容都是document对象的后代节点
			每个网页内容都是一个节点对象（node）
			Node对象：
				三大属性：
					nodeType：节点的类型（数字）
							9：document
							1：element
							2：attribute
							3：text
						何时使用：区分节点的类型时
						问题：无法进一步区分元素名称
					nodeName：节点名称（字符串）
						document：#document
						element：标签名（大写）
						attribute：属性名
						文本节点：#text
						何时：进一步区分元素的名称时
					nodeValue：节点值
						document：null
						element：null
						attribute：属性值
						text：文本内容
	DOM操作：对DOM树上的内容执行四大操作：增删改查
	任何DOM操作的顺序：先找元素再操作
	DOM查找：
		节点树：
		按节点关系查找：
		父子关系：
			node.parentNode 获得node父节点
			node.childNodes 获得所有直接子节点
			node.firstChild 获得node下第一个子节点
			node.lastChild 获得node下最后一个子节点
		兄弟关系：
			node.previousSibling 获得node前一个兄弟
			node.nextSibling 获得node下一个兄弟
		问题：网页中一切都是节点，甚至看不见的换行和空字符都是节点（干扰）
		解决：元素树（仅包含元素节点的树）
			元素树不是一棵新树，仅是节点树的子集
		按元素查找：
			父子元素：
				node.parentElement
				node.children
				node.firstElementChild
				node.lastElementChild
			兄弟元素：
				node.previousElementSibling
				node.nextElementSibling
			如果已知某些元素，就可用这些查找
		递归遍历：
			1. 定义函数，仅遍历直接子节点
			2. 对每个子节点执行和父节点完全相同的方法
		深度优先算法：在同时有子节点和兄弟节点情况下，总是优先遍历子节点。所有子节点遍历完，才遍历兄弟节点
		问题：递归遍历效率极地
		解决：用循环代替递归
		遍历API：节点迭代器
			按照深度优先的顺序依次遍历每个子节点的对象
			节点迭代器的顺序，默认就是深度优先——同递归遍历
		如何：
			1. 创建节点迭代器对象
				var iterator=document.createNodeIterator(
					parent,NodeFilter.SHOW_ALL,null,false
				)
			2. 用循环反复调用节点迭代器对象的nextNode()
				每调用一次，节点迭代器就向下跳一个节点
				var node;
				while((node=iterator.nextNode())!=null){
					console.log(node)//获得当前node节点
				}
		按照HTML查找：
			1. 按id查找：document.getElementById() //只能使用document调用
			2. 按标签名：parent.getElementsByTagName() //可查找所有后代子节点
			3. 按name属性查找：document.getElementsByName()
			4. 按class属性查找：document.getElementsByClassName() //可查找所有后代子节点
		这些查找返回的是动态集合：不实际存储数据，每次访问集合，都重新查找DOM树
			优点：首次查找返回速度快
			缺点：反复访问集合，导致反复查找DOM树
		HTMl查找问题：每次都能用固定条件查找
		按选择器查找（当查找条件复杂时）：
			1. 仅查找一个元素：parent.querySelector()
			2. 找多个元素：parent.querySelectorAll()
			会返回非动态集合（实际存储数据，即使反复访问集合也不会导致反复查找）
		getXXX vs Selector API
			1. 返回值：getXXX返回动态集合，Selector返回非动态集合
			2. 效率：getXXX首次查找效率高，Selector首次效率低
			3. 易用性：Selector API更简单，getXXX更繁琐
			如果通过一个条件就可得到元素时，就用getXXX
			如果条件复杂时，首先Selector API
		修改：
			1. 内容：
				修改HTML代码段：element.innerHTML
				修改文本：element.textContent IE8（innerText）
					1. 去掉内嵌的子标签，只返回文字
					2. 将转义字符转为符号
			2. 属性：
				1. 核心DOM：可操作一切结构化文档的API（HTML XML）
					获取属性值：var value=elem.getAttribute("属性名");
					修改属性值：elem.Attribute("属性名","值");
					判断是否包含属性：var bool=elem.hasAttribute("属性名");
					移除属性：elem.removeAttribute("属性名");
					优点：万能
					缺点：繁琐
				2. HTML DOM：对核心DOM中部分常用API的简化
					一切HTML标准属性都被HTML DOM封装在元素对象中
					elem.属性名（效果和用API一样，如果属性不存在就是""）
					优点：简单
					缺点：不是万能
				开发时不必区分概念，优先使用简单的，如果简单的不能实现，就用核心
				状态属性（核心DOM干不了）：selected disabled checked
			3. 样式：
				内联样式：elem.style.CSS属性名（去横线变驼峰）
					问题：无法获得完整样式（外部样式）
					解决：computed（获得最终元素完整样式）
				var style=getComputedStyle(elem)
					获得elem计算后的样式
					style.属性名可获取值（只读）
				总结：只要修改样式：elem.style.css属性名（因为优先级最高，仅当前元素可用）
							只要获得样式：getComputedStyle(elem) 可获得计算后的完整样式
		添加和删除：
			添加：
			1. 创建新元素
				var elem=document.createElement("标签名");
			2. 设置关键属性
				elem.href="";
				elem.innerHTML="";
			3. 将新元素添加DOM树
				1. 追加：在父元素结尾添加新元素
					parent.appendChild(elem);
				2. 插入：现有子元素之前新元素
					parent.insertBefore(elem,oldElem);
				3. 替换：替换现有的子元素
					parent.replaceChild(elem,oldElem);
			尽量少操作DOM树
			如果同时添加父元素和子元素时，都要在内存中将子元素添加到父元素中，再渲染
			创建文档片段：var elem=document.createDocumentFragment()
			删除：parent.removeChild(child);
	HTML DOM常用对象：
		Image：代表页面上的一个img元素
				创建：var img=new Image();
		Select/Option：
			Select.options（获得select下所有对象）
			Select.options.length（获得option个数）
			Select.value（select选中项的值）
				如果选中的option有value属性，返回value属性
				如果选中的option没有value属性，返回内容
			Select.selectedIndex（获得当前选中项的下标）
			Select.add(option)（添加option）
			Select.remove(i)（删除select下i位置的option）
			事件：onchange（当选中项发生改变时）
			var opt=new Option(text,value); 创建一个option
			option.text（innerHTML）
		Table：
			创建行分组，删除行分组，获取行分组
				table.createTHead();//创建一个行分组，添加到table中，返回当前元素
				table.deleteTHead();//删除行分组
				table.THead;//获取行分组
			TBody：一个table中可包含多个tbody
				获得：table.TBodies[i]
				删除：没有table.deleteTBody() table不能删除tbody
			行：创建，删除，获取
				thead.insertRow(i)//i省略表示末尾追加一行
				thead.deleteRow(i)
				thead.rows//获取所有行
				tr.rowIndex //获取当前tr的位置
					table.deleteRow(tr.rowIndex);
			单元格：创建，删除，获取
				tr.insertCell(i)
				tr.deleteCell(i)
				tr.cells
				只能添加td，不能添加th
		Form：
			获取 var form=document.forms[i/id/name]
			form.elements[i/id/name]
				form.name属性值
			form.length
			form.focus() //获得焦点
			form.blur() //失去焦点
			button.submit() //手动提交		
BOM:Browser Object Model
	专门操作浏览器的API
	问题：没有标准->兼容性问题，使用越来越少
	包括DHTML模型
		window两个角色：
			1. 代替global充当全局变量
			2. 封装所有BOM和DOM的API
		history：封装当前窗口打开后的历史记录栈
		location：封装当前窗口正在打开的URL对象
		navigator：封装浏览器的配置信息
		document：DOM
		screen：封装了显示设备的信息
		event：封装了事件对象
	打开和关闭窗口：
		window.open() //可以返回窗口对象
		window.close()
		打开超链接的方式：4种
			1.替换当前窗口，可后退
				html: target=_self
				js: window.open("url","_self");
			2.替换当前窗口，不可后退
				js: window.location.replace("url");
				//用新URL替换history中当前URL，实现禁止后退
			3.在新窗口打开，可打开多个
				html: target=_blank
				js: window.open("url","_blank");
			4.在新窗口打开，只能打开一个
				1. html: target="key"
				2. window.open("url","key");
			每个窗口都有一个name属性
			name属性是内存中唯一标示一个窗口
			相同name属性的窗口只能开一个，后开的会替换先开的
			预定义name属性：
				_self 自动获取当前窗口的name
				_blank 随机生成name
	窗口大小：
		获取完整窗口大小
			window.outerWidth
			window.outerHeight
		获取文档显示区大小
			window.innerWidth
			window.innerHeight
		打开固定大小位置的窗口：
			window.open("url","_blank","width=100,height=100,left=100,top=100");
		修改窗口大小（只限于弹出窗口）
			window.resizeTo(width,height);
			window.resizeBy(width增量,height增量);
		修改窗口位置：
			1. 在弹出窗口时可以修改（同上）
			2. 弹出窗口后修改位置：
				window.moveTo(left,top);
				window.moveBy(left增量,top增量);
	三大对话框：
		alert() prompt() confirm()
	定时器：
		让浏览器按指定时间自动执行任务
		周期性定时器：让浏览器反复执行一项任务
			1. 任务函数：定时器每次自动调用的函数
			2. 启动定时器：var timer=setInterval(函数,时间间隔) //毫秒
			3. 停止定时器：
				1. 手动：clearInterval(timer)
				2. 自动：在任务函数中判断临界值，达到临界值自动调用clearInterval
		一次性定时器：让浏览器等待一段时间后，自动执行一次任务
			1. 任务函数
			2. 启动定时器：var timer=setTimeout(函数,等待时间ms)
			3. 停止定时器：clearTimeout(timer)
		定时器中的回调函数必须在主程序最后一句话执行完才能开始执行
		回调函数中的this代表的window
	BOM常见对象:
		1. history:封装当前窗口打开后成功访问过的URL的历史记录栈
			history.go(n)
				前进：history.go(1)
				后退：history.go(-1)
					如果不管用，可以 history.go(-2)
				刷新：history.go(0)
		2. location：封装当前窗口正在打开的URL
			location属性：
				location.href 保存完整URL地址
				.protocol 协议
				.host（.hostname 主机名 和.port 端口号）主机
				.pathname 相对路径
				.hash 锚点
				.search url后?后的东西（查询字符串）
			location的方法：
				location.assign("url") //当前窗口打开URL
					-> location.href=""
					-> location=""
				location.replace("url") //当前窗口打开URL，禁止后退
				location.reload(false/true) //重新加载当前页面
					参数：force（强制），是否绕过缓存，直接从服务器获取数据
						默认是false，不强制
		3. navigator：封装浏览器配置信息的对象（没有标准）
			.cookieEnabled //判断是否启用了cookie
				在客户端持久保存数据的小文件
				内存中的数据（变量，数组，对象）都是临时的！
				只要希望在客户端永久保存数据时，就用cookie
			.plugins //封装了浏览器安装的所有插件信息
				.plugins[0].name //表示插件的名字
				.plugins["插件名"]
			.userAgent：包含浏览器名称，内核和版本号的字符串
				鉴别五大浏览器：
		4. screen：显示设备（整个显示器）的分辨率大小
				screen.width
				screen.height
					width>=1200 大屏
					width>=992 中屏
					width>=768 小屏
					width<768 超小屏
				去掉任务栏之后的剩余分辨率
					screen.availWidth/Height
		5. event（事件）：浏览器自动触发的或用户手动触发的页面状态的改变
			只要希望当事件发生时，自动调用一个函数，都要在事件发生前将函数绑定到事件属性上
			1. 在html中绑定事件 <any on时间名="fun"></any>
					问题：不符合内容与行为分离的原则，不便于维护！
					解决：在js中动态绑定事件
			2. 为事件属性赋值一个函数
					elem.on事件名=fun;
					fun不要加()，因为是回调
					fun中的this指向elem
					一个事件只能绑定一个处理函数
						解决：用addEventListener
			3. 一个事件绑定多个函数
					elem.addEventListener("事件名",fun)
					elem.removeEventListener("事件名",fun)
事件模型：
	DOM的3个阶段：
		1. 捕获：由外向内，记录各级父元素上绑定的事件
				addEventListener("事件",fun,capture)
				capture（布尔）：是否在捕获阶段提前触发，默认是false
		2. 目标触发：首先触发目标元素（实际触发事件的元素）上的事件处理函数
		3. 冒泡：按照捕获顺序的反向，由内向外触发各级父元素绑定的事件处理函数
事件对象：当事件发生时，自动创建的，封装所有事件信息的对象
		只要希望操控事件或获得事件相关数据，都要用事件对象
		获取：事件对象默认作为事件处理函数的第一个参数传入
			function fun(event){} //参数event在事件发生时自动获得事件对象
			取消冒泡：event.stopPropagation();
		preventDefault() 取消事件的默认行为
		stopPropagation() 取消事件冒泡对当前节点无影响
		cancelBubble() 取消事件冒泡
		利用冒泡：
			优化：尽量少的添加事件监听
				浏览器在事件发生时，会遍历所有注册的事件监听，监听越多，遍历越慢，速度越慢
				解决：如果多个子元素绑定相同事件时，只需在父元素集中绑定一次，所有子元素共用即可
									如何获得目标元素：event.target //始终保存目标元素，不随冒泡改变
		取消事件：阻止默认行为
			当事件发生后，不希望事件在执行浏览器默认行为时
			event.preventDefault()
		事件坐标：事件发生时，鼠标的位置
			相对于屏幕左上角：event.screenX|screenY
			相对于显示区左上角：event.clientX|clientY
			相对于事件绑定的元素：event.offsetX|offsetY
		页面滚动：
			事件：document.body.onscroll
			获得页面滚动过的高度：document.body.scrollTop或document.documentElement.scrollTop
		元素距离文档顶端和左边的偏移值  
		(javascript)    DOM元素对象.offsetTop
		(javascript)    DOM元素对象.offsetLeft
		(jqurey)         jq对象.offset().top
		(jqurey)         jq对象.offset().left
	
H5十大新特性：
	1. 新的语义标签和属性
	2. 表单新特性
	3. 视频和音频
	4. Canvas绘图
	5. SVG绘图
	6. 地理定位
	7. 拖放API
	8. WebWorker
	9. WebStorage
	10. WebSocket

H5表单新特性：
	1. 新的input type
		<input type=email> //邮件输入域
		<input type=url> //URL地址输入域
		<input type=tel> //电话号码输入域
		<input type=search> //搜索输入域
		<input type=color> //颜色选择控件
		<input type=date> //日期选择控件
		<input type=month> //月份选择控件
		<input type=week> //星期选择控件
		<input type=range min=50 max=100 step=5> //范围选择控件
		<input type=number min=0 max=100 step=2> //数字输入域，step是步长
	2. 新的表单元素
		1. datalist //数据列表，配合option使用，默认隐藏，写个id，然后设置另一个输入框list属性为它的id，即可实现下拉列表
		2. progress //下载进度，value可以设置进度（百分之），不写就自己动
		3. meter 
			//刻度尺，它有一些属性：
			//min范围最小值 max范围最大值 low及格值 high最优值 optimum合理上限值 value实际值
		4. output
	3. 表单标签的新属性
		已有的属性：id,class,title,style,type,name,value,checked,selected,disable,readonly
		新增属性：
			1. autocomplete=on/off //输入框是否显示历史记录
			2. placeholder //占位符，用于输入框中显示提示性文字，不会被提交
			3. autofocus=true/false //自动获得输入焦点
			4. multiple=true/false //是否允许多个输入值（用逗号分割）
			5. form //为一个元素指定form属性，值为某form标签的ID，则此输入域可以放到整个表单的外部
			6. required=true/false //必填项，默认为false
			7. maxlength //输入域最大字符数
			8. minlength //输入域最小字符数
			9. max //限定数字最小值
			10. min //限定数字最大值
			11. step //限定输入数字的步长
			12. pattern //可以写正则表达式
自定义表单中的错误消息内容
	H5为每个标签对应的js对象添加了新属性：validity（对象）
		badInput //无效的输入
		typeMismatch //类型不匹配
		valueMissing //值缺失，如required验证失败
		tooLong //输入内容超过maxlength限制
		tooShort //输入内容不满足minlength限制
		rangeOverflow //输入的数字超过了max
		rangeUnderflow // 输入的数字不满足min
		stepMissmatch //步长不匹配
		patternMismatch //正则表达式不匹配
		customError //是否存在自定义错误
		vaild //输入值是否有效
	设定自定义错误消息：
		obj.setCustomvalidity(""); //取消写空字符串
H5的音视频：
	视频播放：
	<video>（300*150 的inline-block）
	<video><source src=""></video>
	<video src=""></video>
	可以支持视频格式：mp4 ogg webm
	它的属性：
		1. autoplay=true/false //是否自动播放
		2. controls=true/false //播放控件是否显示，不同浏览器外观不同
		3. currentTime //默认值0，当前播放的时间点(s)
		4. duration //影片的总时长(s)
		5. ended=true/false  //是否播完
		6. loop=true/false //是否循环
		7. muted=true/false //是否静音
		8. volume //音量设置(0~1)
		9. paused=true/false //当前是否处于暂停状态
		10. poster //视频第一帧播放前的电影海报
		11. preload //指定视频的预加载方案
			auto //默认值，自动加载宽高，时长，第一帧内容，并缓冲一定的时长
			metadata //元数据，只加载宽高，时长，第一帧位置，不缓冲
			none //什么都不加载
	它的对象方法：
		play() //开始播放
		pause() //暂停播放
		onpause //暂停视频事件
		onplay // 开始视频事件
		onplaying //视频播放中的事件
		onended //视频结束事件
	音频播放：
		<audio src="xxx.mp3"></audio>
		<audio> //浏览器会依次尝试播放，如果都不行就显示文字
			<source src='1.mp3' />
			<source src='1.ogg' />
			您的浏览器不支持html音频
		</audio>
		支持格式：mp3 ogg wav
		和视频的标签属性，对象方法一样
H5绘图技术：
	网页绘图可以使用的功能：
		1. 实时走势图
		2. 统计图表
		3. 随机内容图片
		4. 在线画图板
		5. H5游戏
	可用的绘图技术：
		1. Canvas技术（用于绘制2D）
		2. SVG技术（用户绘制矢量图）
		3. WebGL技术（目前不是H5标准，功能最强大，做3D）
	Canvas绘图技术：
		<canvas></canvas>
		往画布上绘图需要使用其对应的画笔对象：
		var ctx = c.getContext("2d"); //绘图上下文（画笔）
			fillStyle:'#000' //填充样式
			strokeStyle:'#000' //描边样式
			lineWidth:1 //线宽
			font:'10px sans-serif' //字体大小 字体样式
			textBaseline:'alphabetic' //文本对齐基线
			shadowOffsetX:0 //阴影水平偏移量
			shadowOffsetY:0 //阴影垂直偏移量
			shadowColor:'rgba(0,0,0,0)' //阴影颜色，透明
			shadowBlur:0 //阴影的模糊半径
		所有的绘图任务都由画笔实现
			绘制矩形（定位点在自己的左上角）：
				属性：
				fillStyle:'#000' //填充样式
				strokeStyle:'#000' //描边样式
				lineWidth:1 //线宽
				lineJoin:'bevel' //修改线拐点的样式，round圆角，bevel斜面，miter尖角
				方法：
				fillRect(x,y,w,h) //填充一个矩形
				strokeRect(x,y,w,h) //描边一个矩形
				clearRect(x,y,w,h) //删除一个矩形范围
			绘制文本（定位点在文本基线的起点）：
				textBaseline:'alphabetic'
					//文本对齐，默认是基线，可改为top/bottom/alphabetic
				font //先写字号，空格，字体
				fillText(txt, x, y); //填充文本
				strokeText(txt, x, y); //描边文本
				measureText(txt) //测量指定文本的宽度
			创建渐变对象：
				var g = ctx.createLinearGradient(x,y,x1,y1);
				g.addColorStop(0.5, "green"); //添加颜色点
				ctx.fillStyle = g; //把填充样式设置为“渐变对象”
				ctx.strokeStyle = g; //描边设为渐变
		使用Canvas绘制路径和图像：
			ctx.beginPath() //开始一条新路径
			ctx.closePath() //关闭路径，让最后一个锚点自动连接到第一个锚点
			ctx.moveTo(x, y); //移动到指定点
			ctx.lineTo(x, y); //当前点到指定点绘制直线路径
			ctx.arc(x, y, 圆的半径, 开始角度, 结束角度, 是不是逆时针) 
				//绘制拱形路径，定位点在圆心
				//角度用PI表示，1PI是半圆
			ctx.ellipse() //绘制椭圆路径
			ctx.bezierCurveTo() //绘制贝塞尔曲线路径
			ctx.stroke() //描边路径
			ctx.fill() //填充路径
			ctx.clip() //路径裁切
			ctx.lineCap // 更改线的类型
			ctx.lineJoin // 更改线拐角的类型
		使用canvas绘制图像
			ctx.drawImage(img, x, y, w, h);
				//定位点在图片左上角。宽高可不写
				var img = new Image();
				img.src = "xx.jpg";
				img.onload = function() {
					ctx.drawImage(img, x, y);
				}
		对画笔的操作：
			ctx.rotate(10*Math.PI/180);
				//画笔旋转10度，具有累加效应
				//默认旋转是以原点为轴心
			ctx.translate(x, y);
				//画笔平移（原点平移）
			ctx.scale(); // 画笔缩放
			ctx.save(); //保存画笔当前变形数据
			ctx.restore(); // 恢复画笔变形数据
	为canvas中的图形绑定事件监听：
		为canvas元素绑定元素，再判断坐标，只能给规则图形绑定
	SVG（Scalable Vector Graphiph）绘图技术：
		可以单独写在xml中(拓展名时svg)，用html引用
			<?xml version="1.0" encoding="UTF-8" ?>
			<svg xmlns="http://www.w3.org/2000/svg">
			</svg>
			网页中引入：<img src="svg.xml">
		注意：svg图形可以用html属性赋值，也可以使用css（不接受普通css属性，只能用专有的css属性，就是它的属性）
		常见属性：width height x y 
			fill(填充颜色) fill-opacity(填充不透明度)
			stroke(描边颜色) stroke-width(描边宽度)
		如果使用dom创建元素的话，使用命名空间：
			document.createElementNS("http://www.w3.org/2000/svg", "rect")
		<rect> //画矩形
		<circle> //画圆形，属性：r半径长度，cx原点x坐标，cy原点y坐标
		<ellipse> //画椭圆，属性：rx横向半径，ry纵向半径
		<line> //画直线，x1,y1,x2,y2 起点和终点，可以用<g>包起来，统一设置属性
		<polyline> //折线，属性：points="x1,y1 x2,y2 x3,y3"直接写值
		<polygon> //多边形，属性和polyline一样
		<text>你好</text> //写文字，属性alignment-baseline=hanging以顶部为基线对齐，font系列（和html差不多，family, size）
		<image> //插入图片，属性：xlink:href引入图片链接
		渐变效果：
			<defs> //特效对象
				<linearGradient id=g1 x1=0 y1=0 x2="100%" y2=0>
					<stop offset=0 stop-color="#f00"></stop>
					<stop offset="50%" stop-color="#ff0"></stop>
					<stop offset="100%" stop-color="#0f0"></stop>
				</linearGradient>
			</defs>
			<rect width=100 height=50 fill=url(#g1)></rect>
		滤镜效果：
			<defs>
				<filter id=f1> //滤镜对象
						<feGaussianBlur stdDeviation=2 > //高斯模糊，属性是模糊半径
						</feGaussianBlur>
				</filter>
			</defs>
			<rect width=100 height=50 filter=url(#g1)></rect>
地理定位：
	使用js获取浏览器当前所在的地理坐标，实现LBS(location based service)：
		经度(longitude)，维度(latitude)，海拔(altiude)，速度(speed)
	获取浏览器所在定位信息：
		1. 手机浏览器：
			手机内置的GPS芯片，精度在米级别
			手机通讯基站数据，精度在公里级别
		2. pc中的浏览器：
			ip地址的反向解析，精度公里级别
	H5新增的地理定位对象：window.navigator.geolocation
		getCurrentPosition(定位成功回调, 失败的回调) //获取当前的定位信息
		watchPosition() //不断的监视定位信息的改变
		clearWatch() //清除监视
	如何在页面中使用百度地图：
		1. 有一个百度账号
		2. 为自己的网站申请一个使用百度地图的秘钥
		3. 创建html网页，引入百度地图提供的js文件，使用其中的对象
H5的拖放API：
	拖动：Drag  放下：Drop
	elem.draggable = true; //使用拖拽事件
	H5为拖放效果提供了7个事件：
		1. 拖动(source)源对象事件
			ondragstart //拖动开始
			ondrag //拖动进行中
			ondragend // 拖动结束
		2. 目标(target)对象事件
			ondragenter //拖动着进入
			ondragover //拖动着在目标上方，需要取消默认行为
			ondragleave //拖动着离开
			ondrop //松手/释放/松开
		3. 拖动和目标事件传递数据（只限drop）：
			e.dataTransfer.setData("K", "V");
			e.dataTransfer.getData("K");
拖拽本地的图片进网页：
	//阻止dragover默认行为：dragleave
	document.ondragover = function(e) { e.preventDefault() }
	document.ondrop = function(e) {
		//阻止document的drop事件默认行为（在当前窗口中打开客户端图片）
		e.preventDefault();
	}
	//拖放的目标对象：#box
	//如果图片释放在此元素上方，需要显示出该图片
	box.ondragover = function(e) {
		e.preventDefault();
	}
	box.ondrop = function(e) {
		//接受数据的类数组
		var files = e.dataTransfer.files;
		//文件读取器
		var reader = new FileReader();
		//把图片内容读取为一个“数据URL”
		reader.readAsDataURL(files[0]);
		reader.onload = function() {
			console.log("客户端文件读取完成");
			console.log(reader.result); //读取的结果
			var img = new Image();
			img.src  = reader.result;
			box.appendChild(img);
		};
	}
H5提供的用于文件输入输出（IO）的对象：
	File //代表一个文件/目录对象
	FileList //代表一个文件列表
	FileReader //用于从文件中读取内容
	FileWriter //用于向文件写入内容
chrome浏览器中的线程模型：
	程序：计算机可以执行的代码，存在磁盘中（静止的）
	进程：把程序调入到计算机内存中，准备执行（活动的）
	线程：是CPU执行进程代码的基本单位（生产任务）
	进程和线程的关系：
		进程是操作系统分配内存的基本单位
		线程处于进程内部，是CPU执行代码的基本单位
		一个进程中至少有一个线程（也可以有多个）
		多条线程间并发执行（宏观看是同时，微观上是轮流执行）
	chrome中的线程模型：
		1. 发起http请求最多可以使用6个并发线程
		2. 负责向页面中执行绘制任务(html/css/js/事件监听)只有1个线程（UI主线程）
			解决耗时js，创建一个新线程（与UI主线程并发执行）
			H5提供了一种类似创建新线程的机制
				new Worker('x.js'); //工人线程，与UI主线程并发执行
				使用：<script> new Worker('js/xxx.js') </script>
			Worker线程天然缺陷：
				浏览器禁止Worker线程操作任何DOM和BOM对象
				浏览器只允许UI主线程渲染
			UI线程给Worker线程发消息：
				var w = new Worker('js/a.js');
				w.postMessage('abc');
			Worker线程接受数据(不用写对象)：
				onmessage = function(e) {
					e.data //就是传来的数据
				}
			Worker线程发消息给UI主线程
				postMessage(msg);
			UI主线程接受数据：
				w.onmessage = function(e) {
					e.data //接受的数据
				}
		Woker本质是一个线程，在UI主线程之外并发执行的线程，用于耗时的js任务，不能操作dom和bom，只能和UI主线程通信
WebStorage：
	web项目中需要存储多种数据，大体有两种存储方法：
		1. 服务器端存储
			1). 数据库：存储项目中核心数据
			2). Session：存储当前用户信息
		2. 客户端存储：不重要，与客户端有关的数据，如浏览记录，内容定制，样式定制
			1). Cookie： 使用比较麻烦、大小限制（4kb）
			2). Flash：逐渐被淘汰
			3). WebStorage：使用简单，大小不超过8mb即可
			4). IndexDB：客户端直接存储对象，目前还不是H5标准
	H5提供了两个	WebStorage对象，用于浏览器中存储客户端访问数据：
		1. window.sessionStorage（会话存储）：
			web会话：指浏览器从连接到某个服务器开始，一系列请求和相应过程，直到浏览器关闭，会话结束
			在浏览器内存中存储的与某个服务器间的一系列的请求和响应过程中产生的数据，都是k:v形式
			当会话结束时（浏览器关闭），会话级数据消失
			sessionStorage['key'] = 'value';
			sessionStorage.length
			var result = sessionStorage['key'];
			sessionStorage.setItem('key', 'value');
			var result = sessionStorage.getItem('key');
			sessionStorage.removeItem('key'); //删除key
			sessionStorage.clear(); //清除所有
		2. window.localStorage（本地/跨会话级存储）：
			在客户端系统/硬盘中存储客户端与服务器间的访问数据，也是k:v形式
			即使关闭浏览器，甚至关闭电脑，也仍然存在，除非手动删除，否则永久存在
			方法和sessionStorage一样
			如何得知localStorage中数据的修改：
				window.onstorage = function() {}
WebSocket：
	心跳请求：定时器+ajax
	缺点：心跳过快，服务器压力大，心跳过慢，实时性差
	解决：WebSocket协议，基于“广播-收听”模型协议，只要客户端连接到服务器上，就不再断开了，一方可以发多条消息，对方只负责接收，而不发送
	WebSocket问题：客户端与服务器是永久连接，导致了服务器可以同时连接的客户端数是有限的
	客户端程序：
		var ws = new WebSocket("ws://127.0.0.1:9999");
		ws.send("data");
		ws.onmessage = function(e) {
			e.data;
		}
		ws.onclose = function() {
			console.log("客户端断开了连接");
		}
		ws.close();

Webrtc
	js获取设备摄像头的数据
		navigator.getUserMedia() //默认
		navigator.webkitGetUserMedia() //兼容webit内核浏览器
		navigator.mozGetUserMedia() //兼容火狐内核浏览器
		navigator.msGetUserMeida() //兼容微软内核浏览器
	navigator.getUserMedia函数的参数
		1. 对象，表示获取视频数据还是音频数据还是都获取
			{video:true,audio:true}
		2. 数据返回成功的回调函数
		3. 数据返回失败的回调函数
	成功回调函数的操作
		获取数据成功后会传入一个steam流数据
		用window.URL.createObjectURL(stream);转换成url
		再用video元素引入即可播放视频
		新语法（直接引入视频数据）：video.srcObject = steam;
	
ES6方面的语法：
低版本的浏览器可以引用brower.js来编译es6的语法
	<script type="text/babel">//es6语法</script>
变量方面的特性：
	let   不能重复声明，可变，块级作用域
	const 不能重复声明，不变，块级作用域
函数方面的特性：
	箭头函数：(a,b,c)=>{document.write(a,b,c)}
		如果只有一个参数，圆括号可以省
		如果只有一个return，花括号和return可以省
函数的参数：
	1.剩余参数可以用...args来获取（名字可变）
		(a, b, ...args) => {}
	2.展开数组（和把数组写下来一样） ...arr
	2.默认参数 (a, b=10)=>{}
解构赋值：
	变量赋值变量 let [a, b] = [1, 2];
	对象赋值变量 let {a, b} = {a: 18, b: 17};
	注意：
	左右两边必须一样
	右边必须是个合法的东西
	声明和赋值必须不能分开
数组方面的新特性：
	1.map //映射，数组每个值计算并返回一个新数组
		let res = arr.map(item=>item*2);
	2.reduce //汇总，数组进去，返回一个值
		let res = arr.reduce(tmp, item, index){
			return tmp + item;
			//tmp是数组两数之和，item是当前数，index是下标
		}
	3.filter  过滤器，符合要求的返回
		let res = arr.filter(item=>item%2==0);
	4.forEach 迭代，就是循环
		let res = arr.forEach((item, index))=>{});
字符串的新特性：
	1.startsWith //以什么字符串开头
		let str = "http://1.com";
		let boo = str.startsWith("http://");
	2.endsWith //以什么字符串结尾，用法同上
	字符串模板：反引号 `a is ${a}`，也可以折行
ES6面向对象：
	类的创建：
	class Person{
		constructor(name, age) {
			this.name = name;
			this.age = age;
		}
		sayHi() {
			console.log(`hello,my name is ${this.name} and my age is ${this.age}`);
		}
	}
	继承：
	class Super extends Person{
		constructor(name, pass, level) {
			super(name, pass);
			this.level = level;
		}
		showLevel() {
			console.log(this.level);
		}
	}
	面向对象的应用（react）：
	1.组件化
	2.JSX(babel)
	
AJAX:
	Asynchronous Javascript And XML：异步的js和xml
	无刷新和提交，动态请求服务器获取数据更新页面
	涉及技术：html, css, js, xml 纯客户端技术
	1. 创建AJAX对象：
		var xhr = new XMLHttpRequest();
	2. 监听服务器返回响应消息事件
		xhr.onreadystatechange = function() {
			if (this.readyState == 4 && this.status == 200) {
				console.log(this.responseText);
			}
		}
	3. 连接服务器
		xhr.open(method, uri, true); //打开服务器的连接，true表示异步，默认是true
	4. 使用xhr对象发起异步http请求消息
		xhr.send(body/null); //发送请求消息，如果是get，直接写到url中
		如果用post请求发数据的话，先要设置
			xhr.setRequestHeader("Content-type","application/x-www-form-urlencoded;charset=UTF-8");
	XHR对象的常用属性和方法：
		XHR对象作用：发起异步HTTP请求，并接收响应
		XHR对象成员属性：
			readyState 表示XHR当前状态，即请求/响应进行到哪一步，取值：
				0 ：unsent 请求消息未发送
				1 ：opened 已经打开服务器连接
				2 ：headers_received XHR已接收到响应消息头部
				3 ：loading XHR正在加载响应消息主体
				4 ：done XHR已经接收完成响应消息
				//只能依次递增，不能后退，自动改变，不能手工赋值
			status 表示响应消息的状态码，当xhr.readyState变为2时才有值
			statusText 响应消息中的原因短句
			responseText 响应消息主体，当xhr.readyState变为4时值才稳定
	XHR对象成员事件：
		onreadystatechange ：xhr.readyState属性值每次改变都会触发该事件
	XHR对象成员方法：
		setRequestHeader(name, value) //设置请求消息头
		getResponseHeader(name) //获取响应消息头
		getAllResponseHeaders() //获取所有响应消息头
	php设置响应头：header("content-type:text/plain");	
	XHR接收五种响应：
		text/plain
		text/html
		application/javascript
		application/xml
		application/json
XML:可拓展的标签语言，本身是一种字符串格式，用于描述批量复合数据
	1.所有数据都放在标签中：<名>数据</名> 或 <名/>
	2.整个XML字符串有且只能有一个根标签
	3.所有的标签名都可以自定义，严格区分大小写，开始和结束标记必须完全一样
	4.每个标签都可以自定义属性，属性必须有值，值必须用引号括起来
	5.每个标签都可有字标签，可以嵌套，不能交叉
	声明xml：<?xml version="1.0" encoding="utf8" ?>	
	加载并解析XML：
		var parser = new DOMParser();
		//parser.parseFromString(xhr.responseText);
	PHP把对象解析为json： json_encode($arr);	
	PHP把json转对象：json_decode(json);
	解析json：JSON.parse(xhr.responseText);
	把对象变为json：JSON.stringify(obj);
跨域请求和JSONP：
	从一个资源请求另一个资源，两者所在的请求地址不同，域名不同，端口号不同，请求协议不同
	浏览器允许跨域的标签：script img link iframe
	浏览器禁止跨域的情形：xhr（所有的浏览器出于安全考虑，禁用了xhr跨域请求，服务器给出了响应消息，但是浏览器不让使用）
	解决方案：
		1. 修改响应消息头部，添加Access-Control-Allow-Origin:http://127.0.0.1
		2. JSONP，填充式json，是一种使用json数据的方式。意思是在json字符串左右添加函数名
	jQuery中的JSONP：
		$.getJSON("http://localhost/a/b/c.php?objName=?", doFn);
			//第二个问号是jq自动生成一个函数名
		$.ajax({ dataType:"jsonp" });
jquery中的AJAX：
	$().load('xxx.php', 数据对象, 响应成功后的回调函数)
		向指定的URL发起异步请求
		有请求数据就用post，没有用get
		获取服务器html片段响应数据，设定为选定元素的innerHTML
	$.get("xxx.php", 数据对象, function(json) { //json参数是响应数据（也可能是html） })
		向url发起异步get请求，请求数据自动追加url后
	$.post() //同上	
	$.getScript() //用法同上，但是会自动接收响应数据（必须是js）自动执行（eval）
	$.getJSON()
		//用法同上，但是会自动接收响应数据（必须是json）自动执行JSON.parse()，数据在函数参数中
	//上面五个函数通病，只能处理成功的响应消息，如果服务器返回错误消息，不会有任何提示
	$.ajax() //使用方法：
		$.ajax( {
			type:"get",
			url:"xxx.php",
			data:"k=v&k=v",
			beforeSend:fn, //请求发送前的回调
			success:fn,       //响应成功后的回调
			error:fn,           //响应失败后的回调
			complete:fn    //响应完成后（不论成败）的回调
		} );
Cookie:
	document.cookie="uname="+name;
	document.cookie="pwd="+pwd; //不用写+=

HTTP协议：
	两个目标：
		1.调试AXAJ应用中“看不见摸不着”的错误
		2.对网站进行访问优化
	URL地址：
		URL：unified resource locator 统一的资源定位符
		URN：unified resource naming 统一的资源命名符
		URI：unified resource idenfier 统一的资源识别符
		URI=URL+URN
		URL地址最完整的格式：
			<scheme>://<user>:<pwd>@<host>:<port>/<path>;<params>?<query>#<frag>
		各种协议默认端口号：
			http 80 超文本传输
			https 443 加密超文本传输
			ftp 21 文件上传下载
			dns 53 域名解析
			smtp 25 邮件传输
			pop3 110 邮件接收
			telnet 23 远程登录
			ssh 22 安全的远程登录
HTTP协议概述：
	hyper text transfer protocol
		超文本传输协议，用来浏览器和web服务器传输文本网页
	HTTP/0.9 1991年，有设计缺陷
	HTTP/1.0 1996年，第一个稳定正式版本
	HTTP/1.1 1999年，目前通用版本
	HTTP/1.0到HTTP/1.1的改进：
		1.虚拟主机：在一个web服务器中并存多个站点
		2.持久连接：一次请求完成后，不马上断开连接，保持一会儿
		3.代理主机：客户端可以通过代理服务器间接访问目标服务器
HTTP协议具体内容，规定了如下两种消息格式：
1.请求消息：客户端发给浏览器
	1. 请求起始行
		请求方法+空格+请求URI+空格+协议版本
		请求方法：
			get   客户端想获得服务器的资源
			post  客户端想传递数据给服务器 
			put   客户端想放置文件到服务器上
			delete 客户端想删除服务器上指定文件
			head  客户端想获得服务器上指定资源的响应头部，不要内容
			connect  连接测试
			trace   追踪
			options  选项，保留以后使用
		get和post的请求比较：
			发起请求：
				get：浏览器中输入URL回车、超链接跳转、js跳转、src/href属性、get表单、AJAX
				post：post方式提交表单，AJAX
			请求数据位置：
				get：追加在URI后，作为查询字符串，以?开头
				post：放在请求主体中
			请求数据类型：
				get：只能是文本字符
				post：可以是任意类型，如视频图片
			能否上传文件：
				get：不能
				post：能
			请求数据长度限制：
				get：有，浏览器或服务器对请求URI长度有限制（如1kb、4kb等）
				post：请求主体没有长度限制
			请求数据需要编码吗？
				都需要
			表达的语义：
				get：获取数据
				post：传递数据
	2. 请求头（Headers）
		1. 请求消息专用头部
			Host:127.0.0.1
				告诉服务器请求的是哪一个虚拟主机
			Accept:text/html
				告诉服务器自己可以接收的响应内容类型
			Origin:http://127.0.0.1
				告诉服务器当前请求来源于哪个域名
			Referer:http://127.0.0.1/index.html
				引用页
			User-Agent:……
				客户端告诉浏览器自己的类型
			Accept-Encoding:gzip
				浏览器在告诉服务器自己接收的响应数据压缩类型
			Accept-Language:zh-CN
				告诉服务器自己可以接收的自然语言，服务器可以据此实现国际化网页
		2. 请求/响应消息通用头部
			Connect:keep-alive
				告诉对方启用持久连接
			Pragma:no-cache //http1.0版本
			Cache-Control:no-cache
				告诉对方如何缓存当前消息主体中的数据
			Date:Thu, 01 Dec 2018 5:00:01 GMT
				消息的创建时间
		3. 请求主体描述头
			Content-Length:10
				请求内容的长度
			Content-Type：
				text/plain //请求数据是普通文本，不编码（有的服务器拒接接收）
				application/x-www-form-urlencoded //请求主体是经过编码后的表单数据
				multipart/form-data //表单中包含上传的文件数据
				客户端告诉服务器自己请求主体内容类型
		4. 客户端自定义头部
	3. CRLF
	4. 请求主体（Body）
		客户端想给服务器传递的数据（只有post和put有）
2.响应消息：服务器发给客户端
	1.响应起始行：
		协议版本+空格+响应状态码+原因短句
		响应状态码：
			1XX（提示性信息）100（Continue 继续上传数据）101（Switching Protocols 切换协议）
			2XX（成功的响应）200（ok 成功响应）201（Created 成功接收数据）
			3XX （需要客户端重定向）301（Moved Permanently 页面永久移走）304（Not Modified 比较缓冲文件最后一次修改时间，判断是不是要重新下载）
			4XX（客户端请求错误）400（Bad Request 无效请求）403（Forbidden 禁止访问）404（Not Found 文件不存在）405（Mothed Not Allowed 请求方法不允许）
			5XX（服务器端运行错误）500（Internal Server Error 服务器内部错误）501（Not Implemented 服务器不理解请求）503（Service Unavailable 服务暂时不可用）505（HTTP Version Not Supported 服务器不支持请求协议）
	2.响应头部：
		1.响应消息专用头
			Server:Apache
				告诉客户端服务器类型
			Last-Modified
				指定资源最后一次修改时间
			Content-Encoding:gzip
				告诉客户端内容经过了gzip压缩
		2.响应消息通用头
			和请求头部一样
		3.响应主体描述头
			Content-Length
				内容长度
			Content-Type
				响应主体内容类型（上百种）
					text/plain
					text/html
					text/css
					application/javascript
					application/xml
					application/json
					image/jpeg
					audio/mpeg3
			4.服务器自定义头
		3.CRLF
		4.响应主体：
			客户端请求的文件内容
		5.修改响应头
			1.修改服务器配置（比较复杂，有些情况下无法修改，如虚拟主机）
			2.若响应文件为HTML，可以声明（是等价物，不是真正的响应头）
				<meta http-equiv='响应头部'>
			3.使用动态语言代码控制响应消息头
				php：header(‘Content-Control:no-cache’); //设置一个响应消息头
	网站优化：
		1.减少域名解析
		2.减少创建连接
		3.减少请求
		4.压缩文件，提升响应速度

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  


		
		
		
		
		