设计原则：
	1. yangi（you aren't gonna need it）：不写不需要的代码
	2. kiss（keep it simple and stupid）：代码越简单越好
	3. dry（don't repeat yourself）：封装代码
	4. 高内聚，低耦合：
		内聚：一个模块内部的不同部分之间的关系
		耦合：不同模块之间的关系
	5. srp（single responsibility principle）：单一责任原则
	6. ocp（open closed principle）：开闭原则（扩展开放，修改关闭）
	7. lcp（least knowlodge principle）：最少知识法则
设计模式：
	总体来说设计模式分为三大类：
	创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。
	结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
	行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。
MVC：model（模型数据） view（视图） controller（控制器）	
什么是AngularJs：
	ng是一个开源的Google维护的框架，实现单页面应用程序，更适用于数据操作频繁场景
为什么用AngluarJs：
	1. 采用MVC设计模式
	2. 双向数据绑定
	3. 依赖注入
	4. 模块化设计
AngularJs系统指令：
	{{}} //里面可以写表达式或ng的变量，也能写入标签属性值中
	ng-app：指定angularJs的作用范围，自动载入并启动ng应用，如果被调用多次，只有第一次是有效的
		<body ng-app> //加到根目录上
	ng-init：初始化变量/数组/对象，多个用分号分隔，不用写var，这些变量在同一个ng-app中其他标签也能用
		<span ng-init="name='gouDan'">{{name}}</span>
	{{表达式}} //计算表达式结果，放入innerHTML中
	ng-bind：和{{}}作用一样，将表达式结果输出到innerHTML中
	ng-repeat：创建重复元素通过数组/对象
		<ul ng-init="arr=[1, 2, 3]">
			<li ng-repeat="(key, value) in arr">{{"key="+key+"value="+value}}</li>
		</ul> //只写一个变量表示value↑
		//这个可以嵌套：父（v in arr） 子（tmp in v）
		如果数组的值是原始类型并重复重复，输出不了
		解决：指定不重复的元素作为key：ng-repeat="v in arr track by $index"
	ng-if：元素是否存在
		<span ng-if="表达式"></span>
		如果为true就挂在dom树上
	ng-src="{{变量}}" //图片引入变量路径，防止浏览器先解析{{}}
	ng-show/hide //显示和隐藏元素(display)
	ng-style //可以放angular的对象/json
	ng-class //可以放angular的数组
	ng-cloak //angular没加载出来不显示元素
	ng-href //和ng-src一样，防止没加载出angular来被用户点击
	表单中的，值为true就执行
		ng-value ng-disable ng-readonly ng-checked ng-selected
	ng-switch //根据变量判断元素的隐藏或显示
		<div ng-switch="2">
			<span ng-switch-when="1">1</span>
			<span ng-switch-when="2">2</span>
		</div>
	ng-bind-template //可以混合写，不只是写表达式
	ng-include //包含一个文件进来
	ng-list //可以把绑定在元素上的ng-model中的数据转成数组
MVC模式：
	1. 声明一个模块：
		var app = angular.module('myApp', ['ng']);
		<html ng-app="myApp"></html>
	2. 声明和调用控制器：
		app.controller('myCtrl', function ($scope) {
			//控制器被调用时执行
			$scope.name = "abc"; //$scope不能变
		});
		<div ng-controller="myCtrl">
			<p>{{name}}</p>
			<p ng-bind="name"></p>
		</div>
自定义指令：
	var app = angular.module("myModule", ["ng"]);
	app.directive("aBc", function() {
		return {
			template: "<h1>hello{{testName}}</h1>",
			restrict: "EACM", //可以用于属性，标签，class，注释
			replace: true //加上它可以用于注释
			scope: { //需要再写一个test-name属性，拿到参数值
				testName: "@"	},
		}; });
	用法：
	<div a-bc></div>
	<a-bc></a-bc>
	<div class="a-bc"></div>
	<!-- directive: a-bc -->
双向数据绑定：
	方向1：Model数据绑定到View
		实现方法：{{}}、常用指令(ng-repeat)
	方向2：View数据绑定到Model数据
		实现方法：
			<input type=text ng-model="myText" />
			<script>
				var app = angular.module("myApp", ["ng"]);
				app.controller("myCtrl", function($scope) {
					$scope.$watch("myText", function() {
						//视图数据变化操作模型数据
						console.log($scope.myText);
					});
				});
			</script> //定义的myText是一个局部变量
ng-options的使用：
	<select ng-model="city"
		ng-options="city.name for city in cities"></select>
	app.controller("abc", function($scope) {
		$scope.cities = [
			{name: "北京"},
			{name: "上海"},
			{name: "天津"},
		];
		//默认选中第一个
		$scope.city = $scope.cities[0];
	});
过滤器(filter)：
	用在表达式中，实现对表达式结果筛选、过滤、格式化，达到更好的表现效果
	{{表达式 | 过滤器}} // （|）叫管道
	currency:'￥'  //将表达式结果转变为货币样式
	date:"y-MM-dd hh:mm:ss a" //转日期格式，h代表是12时，H代表24时，a可以显示am/pm
	uppercase //转大写
	lowercase //转小写
	orderBy //排序 obj in arr | orderBy:"age":true
	limitTo:10 //限定数组的前几条数据
	number:2 //把数字转为字符串，并限制小数后几位
自定义过滤器：
	let mod = angular.module("mod", []);
	mod.filter("abc", function() {
		retrun funciton(input, arg) { //写代码 }
	});
angular的方法：
	angular.forEach(arr, function(v, k) {
		console.log(`k is ${k} v is ${v}`);
	}) //遍历数组或对象
	angular.uppercase("AbCd") //转大写
	angular.lowercase("AbCd") //转小写
	toJson //将json对象转为json字符串
	fromJson //将json字符串转为json对象
angular服务：
		在ng中服务就是一种单例对象（在每个应用中只会被实例化一次）
		为应用提供一些数据和对象（$scope），都需要注入
		1. 内置的服务（不是$scope方法的都需要注入）：
			$location.absUrl() //获取url地址
			$scope.$digest() //手动数据更新
			$scope.apply() //手动全部数据更新
			$interval(fn, 100) //定时器
			$timeout(fn, 100) //一次性定时器
			$interval.cancel(timer) //清除定时器
			$http //ajax请求
				$http.defaults.header.post = {"content-type": "application/x-www-form-urlencoded"};
				$http.post(url, {a:1, b:2}}).success(function(data) {});
				$http.get(url).then((res)=>{//成功res.data是数据},(res)=>{//失败});
			$q.all([
				$http.get("1.json"),
				$http.get("2.json"),
				$http.get("3.json"),
			]).then(res=>{
				$scope.data1 = res[0].data;
				$scope.data2 = res[1].data;
				$scope.data3 = res[2].data;
			},res=>{}); //批量的异步请求
			post请求默认是json格式传输，如果改需要改配置$http
				$http({
					url:"../data/1.php",
					method:"post",
					data:{a:"132456"},
					headers:{"content-type":"application/x-www-form-urlencoded"},
					transformRequest:function(data) {
						var arr = [];
						for (var key in data)
							arr.push(`${encodeURIComponent(key)}=${encodeURIComponent(obj[key])}`);
						return arr.join("&");	
					}
				}).then((res)=>{
					$scope.inner = res.data;
				});
			也可以改$http依赖：
				模块.config(function($httpProvider) {
					$httpProvider.defaults.headers.post = {"Content-Type":"application/x-www-form-urlencoded"};
					$httpProvider.defaults.transformRequest = function(obj) {
						var arr = [];
						for (var key in obj)
							arr.push(`${encodeURIComponent(key)}=${encodeURIComponent(obj[key])}`);
						return arr.join("&");
					}
				});
			输出html代码的方法：
				$scope.html = $sec.trustAsHtml("<h1>HTML</h1>");
				<div ng-bind-html="html"></div>
		2. 自定义服务
控制器和作用范围：
	$rootScope是$scope的爹，id是1
	其他孩子按照顺序id增加
	如果不同控制器之间传递数据，可以把数据放到$rootScope中
		app.controller("myCtrl", function($scope, $rootScope) {
			//设置的这个数据，所有控制器都能使用
			$rootScope.num = 10;
		});
	如果控制器中包含另一个控制器，那么子控制器可以访问父控制器的数据
		<div ng-controller="myCtrl1"><div ng-controller="myCtrl2"></div></div>
	父作用域对象想调用子作用域对象：
		1. $scope.$broadcast(event, data) //将事件从父亲传给子级
		2. $scope.$emit(event, data) //将事件从子级传给父亲
		3. $scope.$on(event, function(event, data)) //接受事件
模块依赖：父模块的一切东西，都会复制给子模块
jsonp：
	v1.6.4之前：
	$scope.watch("world", function() {
		$http.jsonp("http://xxx.com/1.php?data=123456&fn=JSON_CALLBACK")
	});
	v1.6.4之后：
	let res = $sce.trustAsResourceUrl("xxx.php?data=123");
	$http.jsonp(res, {jsonpCallbackParam: "fn"}).then(res=>{},()=>{});
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
